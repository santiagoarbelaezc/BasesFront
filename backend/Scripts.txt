===Trigger: evitar roles duplicados por nombre===
CREATE OR REPLACE TRIGGER trg_prevent_rol_duplicado
BEFORE INSERT OR UPDATE ON ROL
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM ROL WHERE UPPER(nombre) = UPPER(:NEW.nombre) AND rol_id != :NEW.rol_id;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, '‚ùå Ya existe un rol con ese nombre');
  END IF;
END;
/
===Funci√≥n: obtener nombre del rol por ID====
CREATE OR REPLACE FUNCTION obtener_nombre_rol(p_rol_id IN NUMBER)
RETURN VARCHAR2
IS
  v_nombre VARCHAR2(20);
BEGIN
  SELECT nombre INTO v_nombre FROM ROL WHERE rol_id = p_rol_id;
  RETURN v_nombre;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/
===Procedimiento adicional: resetear nombre por ID (ejemplo de mantenimiento)
CREATE OR REPLACE PROCEDURE resetear_nombre_rol(p_rol_id IN NUMBER)
AS
BEGIN
  UPDATE ROL SET nombre = 'Sin nombre' WHERE rol_id = p_rol_id;
END;
/
===Valida si un rol ya existe, √∫til si deseas llamar a esta funci√≥n antes de insertar o desde otro proceso.====
CREATE OR REPLACE FUNCTION existe_rol(p_nombre IN VARCHAR2)
RETURN BOOLEAN
IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM ROL WHERE UPPER(nombre) = UPPER(p_nombre);
  RETURN v_count > 0;
END;
/
===Verificar existencia de correo===
CREATE OR REPLACE FUNCTION existe_usuario(
  p_correo IN VARCHAR2
) RETURN BOOLEAN
IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USUARIO WHERE LOWER(correo) = LOWER(p_correo);
  RETURN v_count > 0;
END;
/
===Prevenir correos duplicados===
CREATE OR REPLACE TRIGGER trg_prevent_usuario_duplicado
BEFORE INSERT OR UPDATE ON USUARIO
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM USUARIO
  WHERE LOWER(correo) = LOWER(:NEW.correo)
    AND usuario_id != :NEW.usuario_id;

  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20002, '‚ùå Ya existe un usuario con ese correo');
  END IF;
END;
/


===MODULO GRUPO===
CREATE SEQUENCE GRUPO_SEQ START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE INSERTAR_GRUPO (
  p_nombre IN GRUPO.NOMBRE%TYPE,
  p_curso_id IN GRUPO.CURSO_ID%TYPE
) AS
BEGIN
  INSERT INTO GRUPO (GRUPO_ID, NOMBRE, CURSO_ID)
  VALUES (GRUPO_SEQ.NEXTVAL, p_nombre, p_curso_id);
END;


CREATE OR REPLACE PROCEDURE ACTUALIZAR_GRUPO (
  p_grupo_id IN GRUPO.GRUPO_ID%TYPE,
  p_nombre IN GRUPO.NOMBRE%TYPE,
  p_curso_id IN GRUPO.CURSO_ID%TYPE
) AS
BEGIN
  UPDATE GRUPO
  SET NOMBRE = p_nombre,
      CURSO_ID = p_curso_id
  WHERE GRUPO_ID = p_grupo_id;
END;


CREATE OR REPLACE PROCEDURE ELIMINAR_GRUPO (
  p_grupo_id IN GRUPO.GRUPO_ID%TYPE
) AS
BEGIN
  DELETE FROM GRUPO WHERE GRUPO_ID = p_grupo_id;
END;

‚úîÔ∏è EXISTE_GRUPO
Valida si existe un grupo por su ID (para control interno de l√≥gica).
CREATE OR REPLACE FUNCTION EXISTE_GRUPO (
  p_grupo_id IN GRUPO.GRUPO_ID%TYPE
) RETURN BOOLEAN IS
  v_existe NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existe
  FROM GRUPO
  WHERE GRUPO_ID = p_grupo_id;

  RETURN v_existe > 0;
END;

üßæ OBTENER_NOMBRE_GRUPO
Devuelve el nombre del grupo por su ID (por ejemplo, para auditor√≠as, mensajes, referencias cruzadas).
CREATE OR REPLACE FUNCTION OBTENER_NOMBRE_GRUPO (
  p_grupo_id IN GRUPO.GRUPO_ID%TYPE
) RETURN VARCHAR2 IS
  v_nombre GRUPO.NOMBRE%TYPE;
BEGIN
  SELECT NOMBRE INTO v_nombre
  FROM GRUPO
  WHERE GRUPO_ID = p_grupo_id;

  RETURN v_nombre;
END;

üö´ Trigger antirepetidos
Evita insertar un grupo con el mismo nombre dos veces.
CREATE OR REPLACE TRIGGER TRG_PREVENT_GRUPO_DUPLICADO
BEFORE INSERT ON GRUPO
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM GRUPO
  WHERE UPPER(NOMBRE) = UPPER(:NEW.NOMBRE);

  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Ya existe un grupo con ese nombre.');
  END IF;
END;


==== UNIDAD ====

CREATE SEQUENCE UNIDAD_SEQ START WITH 1 INCREMENT BY 1;

‚úÖ CRUD - M√≥dulo: UNIDAD
üì• INSERTAR_UNIDAD
CREATE OR REPLACE PROCEDURE INSERTAR_UNIDAD (
  p_nombre IN UNIDAD.NOMBRE%TYPE,
  p_curso_id IN UNIDAD.CURSO_ID%TYPE
) AS
BEGIN
  INSERT INTO UNIDAD (UNIDAD_ID, NOMBRE, CURSO_ID)
  VALUES (UNIDAD_SEQ.NEXTVAL, p_nombre, p_curso_id);
END;

‚ôª ACTUALIZAR_UNIDAD
CREATE OR REPLACE PROCEDURE ACTUALIZAR_UNIDAD (
  p_unidad_id IN UNIDAD.UNIDAD_ID%TYPE,
  p_nombre IN UNIDAD.NOMBRE%TYPE,
  p_curso_id IN UNIDAD.CURSO_ID%TYPE
) AS
BEGIN
  UPDATE UNIDAD
  SET NOMBRE = p_nombre,
      CURSO_ID = p_curso_id
  WHERE UNIDAD_ID = p_unidad_id;
END;

‚ùå ELIMINAR_UNIDAD
CREATE OR REPLACE PROCEDURE ELIMINAR_UNIDAD (
  p_unidad_id IN UNIDAD.UNIDAD_ID%TYPE
) AS
BEGIN
  DELETE FROM UNIDAD WHERE UNIDAD_ID = p_unidad_id;
END;

üîÅ FUNCIONES
‚úî EXISTE_UNIDAD
CREATE OR REPLACE FUNCTION EXISTE_UNIDAD (
  p_unidad_id IN UNIDAD.UNIDAD_ID%TYPE
) RETURN BOOLEAN IS
  v_existe NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existe FROM UNIDAD WHERE UNIDAD_ID = p_unidad_id;
  RETURN v_existe > 0;
END;
üîç OBTENER_NOMBRE_UNIDAD
CREATE OR REPLACE FUNCTION OBTENER_NOMBRE_UNIDAD (
  p_unidad_id IN UNIDAD.UNIDAD_ID%TYPE
) RETURN VARCHAR2 IS
  v_nombre UNIDAD.NOMBRE%TYPE;
BEGIN
  SELECT NOMBRE INTO v_nombre FROM UNIDAD WHERE UNIDAD_ID = p_unidad_id;
  RETURN v_nombre;
END;
üö´ TRIGGER
TRG_PREVENT_UNIDAD_DUPLICADA
CREATE OR REPLACE TRIGGER TRG_PREVENT_UNIDAD_DUPLICADA
BEFORE INSERT ON UNIDAD
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM UNIDAD WHERE UPPER(NOMBRE) = UPPER(:NEW.NOMBRE);
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Ya existe una unidad con ese nombre.');
  END IF;
END;

===CONTENIDO====
CREATE SEQUENCE CONTENIDO_SEQ START WITH 1 INCREMENT BY 1;

üì• INSERTAR_CONTENIDO
CREATE OR REPLACE PROCEDURE INSERTAR_CONTENIDO (
  p_nombre IN CONTENIDO.NOMBRE%TYPE,
  p_unidad_id IN CONTENIDO.UNIDAD_ID%TYPE
) AS
BEGIN
  INSERT INTO CONTENIDO (CONTENIDO_ID, NOMBRE, UNIDAD_ID)
  VALUES (CONTENIDO_SEQ.NEXTVAL, p_nombre, p_unidad_id);
END;

‚ôª ACTUALIZAR_CONTENIDO
CREATE OR REPLACE PROCEDURE ACTUALIZAR_CONTENIDO (
  p_contenido_id IN CONTENIDO.CONTENIDO_ID%TYPE,
  p_nombre IN CONTENIDO.NOMBRE%TYPE,
  p_unidad_id IN CONTENIDO.UNIDAD_ID%TYPE
) AS
BEGIN
  UPDATE CONTENIDO
  SET NOMBRE = p_nombre,
      UNIDAD_ID = p_unidad_id
  WHERE CONTENIDO_ID = p_contenido_id;
END;

CREATE OR REPLACE PROCEDURE ELIMINAR_CONTENIDO (
  p_contenido_id IN CONTENIDO.CONTENIDO_ID%TYPE
) AS
BEGIN
  DELETE FROM CONTENIDO WHERE CONTENIDO_ID = p_contenido_id;
END;

CREATE OR REPLACE FUNCTION EXISTE_CONTENIDO (
  p_contenido_id IN CONTENIDO.CONTENIDO_ID%TYPE
) RETURN BOOLEAN IS
  v_existe NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existe FROM CONTENIDO WHERE CONTENIDO_ID = p_contenido_id;
  RETURN v_existe > 0;
END;

CREATE OR REPLACE FUNCTION OBTENER_NOMBRE_CONTENIDO (
  p_contenido_id IN CONTENIDO.CONTENIDO_ID%TYPE
) RETURN VARCHAR2 IS
  v_nombre CONTENIDO.NOMBRE%TYPE;
BEGIN
  SELECT NOMBRE INTO v_nombre FROM CONTENIDO WHERE CONTENIDO_ID = p_contenido_id;
  RETURN v_nombre;
END;

===TEMA====

CREATE SEQUENCE TEMA_SEQ START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE INSERTAR_TEMA (
  p_nombre IN TEMA.NOMBRE%TYPE,
  p_contenido_id IN TEMA.CONTENIDO_ID%TYPE
) AS
BEGIN
  INSERT INTO TEMA (TEMA_ID, NOMBRE, CONTENIDO_ID)
  VALUES (TEMA_SEQ.NEXTVAL, p_nombre, p_contenido_id);
END;

CREATE OR REPLACE PROCEDURE ACTUALIZAR_TEMA (
  p_tema_id IN TEMA.TEMA_ID%TYPE,
  p_nombre IN TEMA.NOMBRE%TYPE,
  p_contenido_id IN TEMA.CONTENIDO_ID%TYPE
) AS
BEGIN
  UPDATE TEMA
  SET NOMBRE = p_nombre,
      CONTENIDO_ID = p_contenido_id
  WHERE TEMA_ID = p_tema_id;
END;

CREATE OR REPLACE PROCEDURE ELIMINAR_TEMA (
  p_tema_id IN TEMA.TEMA_ID%TYPE
) AS
BEGIN
  DELETE FROM TEMA WHERE TEMA_ID = p_tema_id;
END;

CREATE OR REPLACE FUNCTION EXISTE_TEMA (
  p_tema_id IN TEMA.TEMA_ID%TYPE
) RETURN BOOLEAN IS
  v_existe NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existe FROM TEMA WHERE TEMA_ID = p_tema_id;
  RETURN v_existe > 0;
END;

CREATE OR REPLACE TRIGGER TRG_PREVENT_TEMA_DUPLICADO
BEFORE INSERT ON TEMA
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM TEMA
  WHERE UPPER(NOMBRE) = UPPER(:NEW.NOMBRE);

  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Ya existe un tema con ese nombre.');
  END IF;
END;

===CATEGORIA===
CREATE SEQUENCE CATEGORIA_SEQ START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE INSERTAR_CATEGORIA (
  p_nombre IN CATEGORIA.NOMBRE%TYPE
) AS
BEGIN
  INSERT INTO CATEGORIA (CATEGORIA_ID, NOMBRE)
  VALUES (CATEGORIA_SEQ.NEXTVAL, p_nombre);
END;

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CATEGORIA (
  p_categoria_id IN CATEGORIA.CATEGORIA_ID%TYPE,
  p_nombre IN CATEGORIA.NOMBRE%TYPE
) AS
BEGIN
  UPDATE CATEGORIA
  SET NOMBRE = p_nombre
  WHERE CATEGORIA_ID = p_categoria_id;
END;

CREATE OR REPLACE PROCEDURE ELIMINAR_CATEGORIA (
  p_categoria_id IN CATEGORIA.CATEGORIA_ID%TYPE
) AS
BEGIN
  DELETE FROM CATEGORIA WHERE CATEGORIA_ID = p_categoria_id;
END;

CREATE OR REPLACE FUNCTION OBTENER_NOMBRE_CATEGORIA (
  p_categoria_id IN CATEGORIA.CATEGORIA_ID%TYPE
) RETURN VARCHAR2 IS
  v_nombre CATEGORIA.NOMBRE%TYPE;
BEGIN
  SELECT NOMBRE INTO v_nombre FROM CATEGORIA WHERE CATEGORIA_ID = p_categoria_id;
  RETURN v_nombre;
END;

CREATE OR REPLACE FUNCTION EXISTE_CATEGORIA (
  p_categoria_id IN CATEGORIA.CATEGORIA_ID%TYPE
) RETURN BOOLEAN IS
  v_existe NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existe FROM CATEGORIA WHERE CATEGORIA_ID = p_categoria_id;
  RETURN v_existe > 0;
END;

CREATE OR REPLACE TRIGGER TRG_PREVENT_CATEGORIA_DUPLICADA
BEFORE INSERT ON CATEGORIA
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM CATEGORIA WHERE UPPER(NOMBRE) = UPPER(:NEW.NOMBRE);
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Ya existe una categor√≠a con ese nombre.');
  END IF;
END;

====DIFICULTAD=====

CREATE SEQUENCE DIFICULTAD_SEQ START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE INSERTAR_DIFICULTAD (
  p_nombre IN DIFICULTAD.NOMBRE%TYPE
) AS
BEGIN
  INSERT INTO DIFICULTAD (DIFICULTAD_ID, NOMBRE)
  VALUES (DIFICULTAD_SEQ.NEXTVAL, p_nombre);
END;

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIFICULTAD (
  p_dificultad_id IN DIFICULTAD.DIFICULTAD_ID%TYPE,
  p_nombre IN DIFICULTAD.NOMBRE%TYPE
) AS
BEGIN
  UPDATE DIFICULTAD
  SET NOMBRE = p_nombre
  WHERE DIFICULTAD_ID = p_dificultad_id;
END;

CREATE OR REPLACE PROCEDURE ELIMINAR_DIFICULTAD (
  p_dificultad_id IN DIFICULTAD.DIFICULTAD_ID%TYPE
) AS
BEGIN
  DELETE FROM DIFICULTAD WHERE DIFICULTAD_ID = p_dificultad_id;
END;

CREATE OR REPLACE FUNCTION OBTENER_NOMBRE_DIFICULTAD (
  p_dificultad_id IN DIFICULTAD.DIFICULTAD_ID%TYPE
) RETURN VARCHAR2 IS
  v_nombre DIFICULTAD.NOMBRE%TYPE;
BEGIN
  SELECT NOMBRE INTO v_nombre FROM DIFICULTAD WHERE DIFICULTAD_ID = p_dificultad_id;
  RETURN v_nombre;
END;

CREATE OR REPLACE FUNCTION EXISTE_DIFICULTAD (
  p_dificultad_id IN DIFICULTAD.DIFICULTAD_ID%TYPE
) RETURN BOOLEAN IS
  v_existe NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existe FROM DIFICULTAD WHERE DIFICULTAD_ID = p_dificultad_id;
  RETURN v_existe > 0;
END;

CREATE OR REPLACE TRIGGER TRG_PREVENT_DIFICULTAD_DUPLICADA
BEFORE INSERT ON DIFICULTAD
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM DIFICULTAD WHERE UPPER(NOMBRE) = UPPER(:NEW.NOMBRE);
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Ya existe una dificultad con ese nombre.');
  END IF;
END;